

UNICIDAD **********************************************************************************************
	
	Verificamos en la gramatica donde existen posibles declaraciones de metodos y de variables.
	
	Codeamos los posibles caminos para llegar a una declaracion de metodo o de variable.

	No pueden existir más de una declaración de método o variable dos veces con el mismo nombre.

	Field Declaration:

		Como field declaration se puede usar no solo al principio, si no que luego en method call, entonces
		recibimos como parametro una tabla, la tabla en el actual scope, para la parte de la gramatica:
		start: (callout_decl)* (field_decl)* (method_decl)*  la tabla que recibe sera la tabla 
		padre(obviamente)

		Para los arreglos se hace caso omiso del valor del tamano del arreglo, solamente tomamos el nombre de la variable y verificamos en la tabla que no existiera y se agregaron como cualquier otra variable

		EJEMPLO 1: ACEPTADA

			int a, b, c, d;
			boolean e, f, g;

		EJEMPLO 2: RECHAZADA

			int a, b;
			boolean a[];

	Method Declaration:

		Empezamos a recorrer por methos declaration.



NOTA: Se agruparon las correspondientes clases a las siguientes reglas de produccion, por cuestion
  	  de sentido y significado:

  	  Res
  	  			#bin1
  	  Negation:
  	  			#bin2
  	  IntBinOp:
  	  			#bin3
  	  			#bin4
  	  ComparisonBinOp
  	  			#bin5
  	  			#bin6
  	  BooleanBinOp
  	  			#bin7
  	  			#bin8

  	  IntBinOp soporta:
		  	  			numeros, 
		  	  			variables que sean numeros

  	  ComparisonBinOp soporta:

  	  					numeros,
  	  					variables que sean numeros
  	  BooleanBinOp soporta:

  	  					booleans,
  	  					variables que sean booleanos
  	  					expresiones que devuelvan booleanos (ComparisonBinOp)

  	  Negation:

bin_op:
    RES bin_op             										             #bin1
  | NO bin_op           													 #bin2
  | bin_op (MULT|DIV|PRCNT) bin_op             								 #bin3		
  | bin_op (PLUS|RES) bin_op             									 #bin4
  | bin_op (MENOR|MAYOR|MENORIGUAL|MAYORIGUAL) bin_op             			 #bin5							
  | bin_op (DIG|NOIGUAL) bin_op                                              #bin6
  | bin_op AND bin_op                                                        #bin7
  | bin_op OR bin_op            								             #bin8
  | expr2                                                                    #bin9
   ;



   Habia una clase llamada Statement1 se cambio de nombre a Asignation, ya que es mas representativo 
   y asi sucesivamente se fue cambiando. Para mas detalles se puede ver en los comentarios en la regla
   de produccion de statement, a cada identificador le corresponde una clase. Anteriormente llamadas
   Statement1, Statement2... y asi sucesivamente.

Para las clasese IfStatement, WhileStatement, ForStatement se crea un nuevo scope (un objeto Table) con el padre que recibe de parametro en el metodo, PERO sin guardar esa tabla en el arbol de tablas, o sea se van a declarar las variables, se hacen todos los chequeos, pero al salir de ese scope, ya no se usan mas y deja de existir la tabla.

IfStatement:======================================

	se crea un scope para la seccion de codigo si la condicion es true
	y otro scope para la seccion de codigo si la condicion es false 


	PRUEBA SUPERADA: cada variabla a en su propio scope, todo bien

	boolean b;
	int a(){
	    int a;
	    if(d){
	      int a;
	      if(s){
	        int a;
	      }
	    }else{
	      boolean a;
	    }

	}

ForStatement:===================================

	PRUEBA SUPERADA:	Error esperado, todo bien

		boolean b;
		int a(){
		    int a;
		    for(a = 3, f){
		      int a;
		      boolean a;
		    }

		}


	PRUEBA SUPERADA:	cada variabla a en su propio scope, todo bien

		boolean b;
		int a(){
		    int a;
		    for(a = 3, f){
		      int a;
		      if(d){
		        int a;
		      }else{
		        int a;
		      }
		    }
		}

WhileStatement: =================================

	PRUEBA SUPERADA: error esperado en el scope de while, todo bien

		boolean b;
		int a(){
		    int a;
		    while(s){
		      int a;
		      boolean a;
		    }
		}

	PRUEBA SUPERADA: cada variable en su propio scope, todo bien

		boolean b;
		int a(){
		    int a;
		    while(s){
		      int a;
		    }
		}

	PRUEBA SUPERADA: combinacion con while, if y for, todo bien

	boolean b;
	int a(){
	    int a;
	    for(a = 3, g){

	      if(x){
	        int a;
	        while(s){
	          int a;
	        }
	      }
	    
	    }
	}